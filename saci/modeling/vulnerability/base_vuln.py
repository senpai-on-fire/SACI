from collections.abc import Hashable
from dataclasses import dataclass
from typing import Generic

from typing_extensions import TypeVar

from saci.modeling.capability import Capability
from saci.modeling.communication import BaseCommunication
from saci.modeling.device import ComponentBase, Device

CID = TypeVar("CID", bound=Hashable)


@dataclass(frozen=True)
class VulnerabilityEffect(Generic[CID]):
    """What the presence of a vulnerability means for our modeling of the device."""

    reason: str  # Why is this effect present? Oftentimes just a stringified version of the vulnerability.

    def apply_to_device(self, device: Device[CID]):
        pass


@dataclass(frozen=True)
class AddEdgesEffect(VulnerabilityEffect[CID]):
    """An effect that adds more edges to the graph."""

    edges: frozenset[tuple[CID, CID]]

    def apply_to_device(self, device: Device[CID]):
        for from_, to_ in self.edges:
            device.component_graph.add_edge(from_, to_, generated=True, generation_reason=self.reason)


@dataclass(frozen=True)
class MakeEntryEffect(VulnerabilityEffect[CID]):
    """An effect that marks a node an entry point for path search."""

    nodes: frozenset[CID]

    def apply_to_device(self, device: Device[CID]):
        for node in self.nodes:
            # TODO: attach reason somehow
            device.component_graph.nodes[node]["is_entry"] = True


@dataclass(frozen=True)
class CapabilityEffect(VulnerabilityEffect[CID]):
    """An effect that adds a capability to be considered by SACI to a component."""

    component_id: CID
    port_id: str | None  # If None, applies to the whole component
    capability: Capability

    def apply_to_device(self, device: Device[CID]):
        if self.port_id is not None:
            device.component_graph.nodes[self.component_id][f"capability_port_{self.port_id}_{self.capability}"] = True
        else:
            device.component_graph.nodes[self.component_id][f"capability_{self.capability}"] = True


class BaseVulnerability(Generic[CID]):
    def __init__(
        self,
        component: ComponentBase,
        _input: BaseCommunication,
        output: BaseCommunication,
        associated_cwe=None,
        attack_ASP=None,
        rulefile=None,
        attack_vectors=None,
    ):
        self.component = component
        self.input = _input
        self.output = output
        self.associated_cwe = associated_cwe
        self.attack_ASP = attack_ASP
        self.rulefile = rulefile
        self.attack_vectors = attack_vectors

    def exists(self, device: Device[CID]) -> bool:
        raise NotImplementedError

    def effects(self, device: Device[CID]) -> list[VulnerabilityEffect[CID]]:
        """What are all the effects this vulnerability has on our modeling of the device?

        Assumes self.exists(device) returns True.
        """

        return []

    def apply_effects(self, device: Device[CID]):
        """Applies all the effects of this vulnerability to the device.

        Assumes self.exists(device) returns True.
        """

        for effect in self.effects(device):
            effect.apply_to_device(device)
